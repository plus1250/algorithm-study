# BFS/DFS 기본

## 1. 깊이 우선 탐색

### 1. 깊이 우선 탐색(DFS)란?

- DFS : Depth First Search
- 하나의 경우의 수에 대하여 모든 경우의 수를 조사하고 다음 경우의 수를 조사하면서 해를 찾는 과정
- 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와 다른 방향으로 다시 탐색을 진행하는 방법과 유사
- 모든 노드를 방문 하고자 할 경우 많이 사용

### 2. 깊이 우선 탐색(DFS)의 구조

![11.png](BFS%20DFS%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%209f636e4714a1424da4623203218ad262/11.png)

### 3. 깊이 우선 탐색(DFS)과 스택

![12.png](BFS%20DFS%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%209f636e4714a1424da4623203218ad262/12.png)

| 검사 중 | 스택 |
| --- | --- |
| A | B, C, D |
| B | E, F, C, D |
| E | J, F, C, D |
| J | F, C, D |
| F | K, L, C, D |
| K | L, C, D |
| L | C, D |
| C | G, D |
| G | 정답, D |
| 정답 | D |

### 4. 깊이 우선 탐색(DFS) 구현

- 미로 찾기
    
    ![13.PNG](BFS%20DFS%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%209f636e4714a1424da4623203218ad262/13.png)
    
    - 주어진 미로가 탈출 가능한 미로라면 True, 탈출 불가능한 미로라면 False를 반환
        
        
        | 검사 중 | 스택 |
        | --- | --- |
        | [0,0] | [0,1] |
        | [0,1] | [0,2], [1,1] |
        | [0,2] | [0,3], [1,1] |
        | [0,3] | [0,4], [1,1] |
        | [0,4] | [0,5], [1,1] |
        | [0,5] | [1,5], [1,1] |
        | [1,5] | [2,5], [1,1] |
        | [2,5] | [3,5], [1,1] |
        | [3,5] | [3,4], [1,1] |
        | [3,4] | [3,3], [1,1] |
        | [3,3] | [2,3], [1,1] |
        | [2,3] | [1,1] |
        | [1,1] | [2,1] |
        | [2,1] | [2,0] |
        | [2,0] | [3,0] |
        | [3,0] | [4,0] |
        | [4,0] | [4,1] |
        | [4,1] | [5,1] |
        | [5,1] | [5,2] |
        | [5,2] | [5,3] |
        | [5,3] | [5,4] |
        | [5,4] | [5,5] |
        | [5,5] | 도착 |
        | 도착 |  |
    
    ```python
    # 스택에 데이터가 있다면
    while len(stack) > 0:
    	# 스택의 가장 마지막 데이터 추출
    	now = stack.pop()
    	# 정답 여부 검사
    	if now == dest:
    		return True
    	x = now[1]
    	y = now[0]
    	# 왼쪽으로 이동할 수 있다면 
    	if x - 1 > -1:
    		# 갈 수 있는 길이라면 스택에 추가하고 방문 여부를 2로 표시
    		if maps[y][x-1] == 0:
    			stack.append([y, x-1])
    			maps[y][y-1] = 2
    	# 오른쪽으로 이동할 수 있다면
    	if x + 1 < hori:
    		# 갈수 있는 길이라면, 스택에 추가하고 방문 여부를 2로 표시
    		if maps[y][x+1] == 1:
    			stack.append([y, x+1])
    			maps[y][x+1] = 2
    	# 위로 이동할 수 있다면
    	if y - 1 > -1:
    		# 갈수 있는 길이라면, 스택에 추가하고 방문 여부를 2로 표시
    		if maps[y-1][x] == 1:
    			stack.append([y-1, x])
    			maps[y-1][x] = 2
    	# 아래로 이동할 수 있다면
    	if y + 1 < verti:
    		# 갈수 있는 길이라면, 스택에 추가하고 방문 여부를 2로 표시
    		if maps[y+1][x] == 1:
    			stack.append([y+1, x])
    			maps[y+1][x] = 2
    # 스택에 데이터가 없으면 False
    return False
    ```
    

## 2. 너비 우선 탐색

### 1. 너비 우선 탐색(BFS)란?

- BFS : Breadth First Search
- 하나의 경우의 수에 대한 다음 단계의 모든 경우의 수를 조사하면서 해를 찾는 과정
- 말 그대로 시작 정점으로부터 가까운 정점을 먼저 방문하고, 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법
- 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 많이 사용

### 2. 너비 우선 탐색(BFS) 구조

![14.png](BFS%20DFS%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%209f636e4714a1424da4623203218ad262/14.png)

### 3. 너비 우선 탐색(BFS)과 큐

![15.png](BFS%20DFS%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%209f636e4714a1424da4623203218ad262/15.png)

| 검사 중 | 큐 |
| --- | --- |
| A | B, C, D |
| B | C, D, E, F |
| C | D, E, F, 정답 |
| D | E, F, 정답, H, I |
| E | F, 정답, H, I, J |
| F | 정답, H, I, J, K, L |
| 정답 | H, I, J, K, L, |

### 4. 너비 우선 탐색(BFS) 구현

- 최단 경로 찾기
    
    ![16.PNG](BFS%20DFS%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%209f636e4714a1424da4623203218ad262/16.png)
    
    - 1번 섬에서부터 12번 섬까지 가는 최단 경로는 얼마인가? (단, 모든 경로의 거리는 1이다.)
        
        
        | 검사 중 | 큐 | 거리 X의 개수 |
        | --- | --- | --- |
        | 1 | 2, 5, 6 | 0 = 3 |
        | 2 | 5, 6, 3, 11 | 0 = 2 |
        | 5 | 6, 3, 11, 9 | 0 = 1 |
        | 6 | 3, 11, 9, 12 | 0 = 0 |
        |  | 3, 11, 9, 12 | 2 = 4 |
        | 3 | 11, 9, 12, 7, 8 | 2 = 3 |
        | 11 | 9, 12, 7, 8,  | 2 = 2 |
        | 9 | 12, 7, 8, 10 | 2 = 1 |
        | 12 | 7, 8, 10 | 2 = 0  |
    
    ```python
    # 큐에 데이터가 있다면
    while len(queue) > 0:
    	# 같은 거리에 있는 큐 데이터의 갯수
    	count = len(queue)
    	# 같은 거리에 있는 큐 개수 만큼 검사
    	for time in range(count):
    		now = queue.pop(0)
    		# 정답이 존재하면 값 반환
    		if now == dest:
    			return answer
    		# 연결된 포인트 완전 탐색
    		for i in data:
    			# 방문하지 않은 연결된 길이라면 큐에 추가하고 방문 표시
    			if i[0] == now and visited[i[1]-1] == False:
    				queue.append(i[1])
    				visited[i[1]-1] = True
    			elif i[1] == now and visited[i[0]-1] == False:
    				queue.apeend(i[0])
    				visited[i[0]-1] = True
    	# 거리를 1 더 벌린다.
    	answer += 1
    return answer
    ```